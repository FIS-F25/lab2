# Hash-based Authentication

1. It's probably better to store password hashes in a database instead of plaintext passwords in code. Create `init_db.py` to intitialize a SQLite database following this method.

   ```copy
   import sqlite3

   if __name__ == '__main__':
      open('db.sqlite','w').close()
      conn = sqlite3.connect('db.sqlite')
      conn.execute('CREATE TABLE Users(name TEXT, pass_hash TEXT)')
      conn.execute(f'INSERT INTO Users(name, pass_hash) VALUES("admin", "891f490e5d7bdb06d90d56f8d7db405f")')
      conn.commit()
      conn.close()
   ```

   ```execute
   python3 init_db.py 
   ```

2. Modify `app.py` to read values from the db.

   ```copy
   from flask import Flask
   from flask_httpauth import HTTPBasicAuth
   from hashlib import md5
   from sqlite3 import connect

   app = Flask(__name__)
   auth = HTTPBasicAuth(app)
   conn = connect('db.sqlite')
   users = {
      "admin": conn.execute('SELECT pass_hash FROM Users WHERE name="admin"').fetchone()[0]
   }

   @auth.verify_password
   def verify_password(username, password):
      if username in users and md5(password.encode()).hexdigest() == users[username]:
         return username

   @app.route('/')
   @auth.login_required
   def home():
      return f'<h1>Hello, {auth.current_user()}</h1>'

   if __name__ == '__main__':
      app.run()
   ```

## Exercise 1

Hack this app using at least **two different approaches** (i.e., get admin password then log in using it).

Options:

1. Online brute-forcer (Python) against the app
2. Offline brute-forcer (Python) against the hash
3. Reverse hash lookup websites (rainbow table)

For options 1 and 2, assume you know that the password won't exceed 4 lowercase english letters.

**Additionaly**, what could be a mechanism to protect against the first attack option? (mentioning technical terms is enough).
